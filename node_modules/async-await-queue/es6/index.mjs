class t{constructor(t){this.compare=t,this.heapArray=[],this._limit=0}static getChildrenIndexOf(t){return[2*t+1,2*t+2]}static getParentIndexOf(t){if(t<=0)return-1;const e=t%2?1:2;return Math.floor((t-e)/2)}push(t){return this._sortNodeUp(this.heapArray.push(t)-1),!0}length(){return this.heapArray.length}peek(){return this.heapArray[0]}pop(){const t=this.heapArray.pop();return this.length()>0&&void 0!==t?this.replace(t):t}replace(t){const e=this.heapArray[0];return this.heapArray[0]=t,this._sortNodeDown(0),e}size(){return this.length()}_moveNode(t,e){[this.heapArray[t],this.heapArray[e]]=[this.heapArray[e],this.heapArray[t]]}_sortNodeDown(e){let i=e<this.heapArray.length-1;const n=this.heapArray[e],s=(t,e)=>(this.heapArray.length>e&&this.compare(this.heapArray[e],this.heapArray[t])<0&&(t=e),t);for(;i;){const r=t.getChildrenIndexOf(e),h=r.reduce(s,r[0]),a=this.heapArray[h];void 0!==a&&this.compare(n,a)>0?(this._moveNode(e,h),e=h):i=!1}}_sortNodeUp(e){let i=e>0;for(;i;){const n=t.getParentIndexOf(e);n>=0&&this.compare(this.heapArray[n],this.heapArray[e])>0?(this._moveNode(e,n),e=n):i=!1}}}function e(t,e){return t.prio-e.prio||t.counter-e.counter}class i{constructor(i,n){this.maxConcurrent=i||1,this.minCycle=n||0,this.queueRunning=new Map,this.queueWaiting=new t(e),this.lastRun=0,this.nextTimer=null,this.counter=0}tryRun(){for(;this.queueWaiting.size()>0&&this.queueRunning.size<this.maxConcurrent;){if(Date.now()-this.lastRun<this.minCycle)return void(null===this.nextTimer&&(this.nextTimer=new Promise((t=>setTimeout((()=>{this.nextTimer=null,this.tryRun(),t()}),this.minCycle-Date.now()+this.lastRun)))));const t=this.queueWaiting.pop();if(void 0!==t){let e;const i={wait:new Promise((t=>{e=t})),signal:e},n={hash:t.hash,prio:t.prio,finish:i};if(this.queueRunning.has(t.hash))throw new Error("async-await-queue: duplicate hash "+t.hash);this.queueRunning.set(t.hash,n),this.lastRun=Date.now(),t.start.signal()}}}end(t){const e=this.queueRunning.get(t);if(void 0===e)throw new Error("async-await-queue: queue desync for "+t);this.queueRunning.delete(t),e.finish.signal(),this.tryRun()}async wait(t,e){const i=null!=e?e:0;let n;const s=new Promise((t=>{n=t})),r={hash:t,prio:i,start:{signal:n,wait:s},counter:this.counter++};this.queueWaiting.push(r),this.tryRun(),await s,this.lastRun=Date.now()}run(t,e){const i=null!=e?e:0,n=Symbol();return this.wait(n,i).then(t).finally((()=>{this.end(n)}))}stat(){return{running:this.queueRunning.size,waiting:this.queueWaiting.size(),last:this.lastRun}}async flush(t){for(;this.queueRunning.size>0||this.queueWaiting.size()>0;){const e=this.queueWaiting.peek();if(e&&await e.start.wait,void 0!==t&&this.queueWaiting.size()<t)return;if(this.queueRunning.size>0){const t=this.queueRunning.values().next().value;await t.finish.wait}}}}export{i as Queue};
//# sourceMappingURL=index.mjs.map
